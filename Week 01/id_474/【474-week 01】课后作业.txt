一、第三课
    1、删除排序数组中的重复项（https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/）
    
        class Solution {
        public:
            int removeDuplicates(vector<int>& nums) {
                if (0 == nums.size())
                    return 0;
                
                int i = 0;
                
                for (int j = 1; j < nums.size(); j++){
                    if (nums[i] != nums[j]){
                        nums[++i] = nums[j];
                    }
                }
                
                return i + 1;     
            }
        };

        时间复杂度：O(n) 空间复杂度：O(1)

    2、旋转数组 (https://leetcode-cn.com/problems/rotate-array/)

        方法一： 暴力法
            class Solution {
            public:
                void rotate(vector<int>& nums, int k) {
                    int size = nums.size();
                    k %= (size);

                    int preValue = 0;
                    int temp = 0;

                    for (int i = 1; i <= k; i++) {
                        preValue = nums[size - 1];

                        for (int j = 0; j < size; j++) {
                            temp = nums[j];
                            nums[j] = preValue;
                            preValue = temp;
                        }
                    }
                }
            };    

            时间复杂度：O(n * k) 空间复杂度：O(1)
        
        方法二：反转
            class Solution {
            public:
                void rotate(vector<int>& nums, int k) {
                    k %= nums.size();
                    reverse(nums.begin(), nums.end());
                    reverse(nums.begin(), nums.begin() + k);
                    reverse(nums.begin() + k, nums.end());
                }
            }; 

            时间复杂度：O(n) 空间复杂度：O(1)  
        
        方法三：
            class Solution {
            public:
                void rotate(vector<int>& nums, int k) {
                    int n = nums.size(), start = 0;
                    
                    for (; k %= n; n -= k, start += k) {
                        for (int i = 0; i < k; i++) {
                            swap(nums[start + i], nums[start + n - k + i]);
                        }
                    }
                }
            };  

            时间复杂度：O(n) 空间复杂度：O(1)   

    3、合并两个有序链表 (https://leetcode-cn.com/problems/merge-two-sorted-lists/)
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */


        方法一： 递归
            class Solution {
            public:
                ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
                    if (NULL == l1) {
                        return l2;
                    }
                    else if (NULL == l2) {
                        return l1;
                    }
                    else if (l1->val < l2->val) {
                        l1->next = mergeTwoLists(l1->next, l2);
                        return l1;
                    }
                    else {
                        l2->next = mergeTwoLists(l1, l2->next);
                        return l2;
                    }        
                }
            };

            时间复杂度：O(n) 空间复杂度：O(n)

        方法二：迭代
            class Solution {
            public:
                ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
                    ListNode* preHead = new ListNode(-1);
                    ListNode* pre = preHead;

                    while (NULL != l1 && NULL != l2){
                        if (l1->val <= l2->val) {
                            pre->next = l1;
                            l1 = l1->next;
                        }
                        else {
                            pre->next = l2;
                            l2 = l2->next;
                        }

                        pre = pre->next;
                    }

                    pre->next = NULL == l1 ? l2 : l1;

                    return preHead->next;
                }
            };  

            时间复杂度：O(n) 空间复杂度：O(1)   












